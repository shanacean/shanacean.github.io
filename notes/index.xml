<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Notes on Bangyang Shan</title>
    <link>shanacean.github.io/notes/</link>
    <description>Recent content in Notes on Bangyang Shan</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 21 Oct 2021 13:18:43 +0800</lastBuildDate><atom:link href="shanacean.github.io/notes/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Concurrency</title>
      <link>shanacean.github.io/notes/concurrency/</link>
      <pubDate>Thu, 21 Oct 2021 13:18:43 +0800</pubDate>
      
      <guid>shanacean.github.io/notes/concurrency/</guid>
      <description>Concurency 4个重要概念:
 A critical section is a piece of code that accesses a shared resource, usually a variable or data structure. A race condition (or data race [NM92]) arises if multiple threads of execution enter the critical section at roughly the same time; both attempt to update the shared data structure, leading to a surprising (and perhaps undesirable) outcome. An indeterminate program consists of one or more race conditions; the output of the program varies from run to run, depending on which threads ran when.</description>
    </item>
    
    <item>
      <title>Tlpi</title>
      <link>shanacean.github.io/notes/tlpi/</link>
      <pubDate>Sun, 19 Sep 2021 10:51:17 +0800</pubDate>
      
      <guid>shanacean.github.io/notes/tlpi/</guid>
      <description>Chapter5 深入探究文件IO 5.1 race conditions 操作共享资源的两个进程（或线程），其结果取决于一个无法预期的顺序，即这些进程(线程)获得 CPU 使用权的先后相对顺序。例如两个进程同时向一个文件尾部添加数据。
 所有系统调用都是以原子操作方式执行的。内核保证了某系统调用中的所有步骤会作为独立操作而一次性加以执行，期间不会为其他进程或线程所中断。
 5.2-3 fcntl 使用fcntl(int fd, int cmd, &amp;hellip;)获取修改访问模式和状态模式。
cmd
 F_SETFL 更新状态标志 F_GETFL 获取当前标志副本  5.4 Relationship Between File Descriptors and Open Files </description>
    </item>
    
    <item>
      <title>Ipconfig_ping</title>
      <link>shanacean.github.io/notes/ipconfig_ping/</link>
      <pubDate>Wed, 15 Sep 2021 14:16:58 +0800</pubDate>
      
      <guid>shanacean.github.io/notes/ipconfig_ping/</guid>
      <description>Ipconfig  /all 显示所有适配器的完整 TCP/IP 配置。 /flushdns 刷新和重置 DNS 客户端解析程序缓存的内容。  实作一
DHCP(Dynamic Host Configuration Protocol)
 用于内部网或网络服务供应商自动分配IP地址给用户 用于内部网管理员对所有电脑作中央管理  Subnet Mask
 用来指明一个IP地址的哪些位标识的是主机所在的网络地址以及哪些位标识的是主机地址的位掩码。  Gateway
 网关（gateway）能在不同协议间移动资料，而路由器（router）是在不同网络间移动资料，相当于传统所说的IP网关（IP gateway）。   实作二
Todo:
 Ping  TTL time to live time 往返时间    ping www.baidu.com域名失败原因可能为域名解析失败，解决方法：
 清除dns缓存 ipconfig/flushdns 重启网卡 service network restart 或修改host文件添加映射ip-域名映射    Tracert Trace Route
实作一
 question1
tracert通过TTL实现，每经过一个路由器，TTL - 1，直到为0时返回，而后主机再将TTL + 1发送，···直到到达目的地结束。how tracert works question2</description>
    </item>
    
    <item>
      <title>Interfaces</title>
      <link>shanacean.github.io/notes/interfaces/</link>
      <pubDate>Thu, 12 Aug 2021 09:04:21 +0800</pubDate>
      
      <guid>shanacean.github.io/notes/interfaces/</guid>
      <description>使用net/http包中handler时，handler的函数签名为func(ResponseWriter, *Request)，分别为传值和指针。在SO上找到了相关问题:
[In Go HTTP handlers, why is the ResponseWriter a value but the Request a pointer?]
ResponseWriter是一个interface，而request是一个具体的struct。
type response 实现了ResponseWtriter的方法，但对外部不可见。
Interface value Interface value是一种类型. 和C++一样，Go使用了method tables记录该接口所包含的方法，不同点在于c++是通过编译期确定，而Go在运行时计算。
Interface value由两个指针组成，一个指向值对应的数据，另一个指向类型信息。
type Stringer interface { String() string } type Binary uint64 func (b Binary) String() string { return strconv.FormatUint(b.Get(), 10) } func (b Binary) Get() uint64 { return uint64(b) } A pointer to interface 当一个函数签名为a pointer to interface时，无法使用interface声明的方法。
type SomeInterface interface { sayHello() } func doSomething(i *SomeInterface) { i.</description>
    </item>
    
    <item>
      <title>Reader Dev</title>
      <link>shanacean.github.io/notes/reader_dev/</link>
      <pubDate>Fri, 04 Jun 2021 15:17:33 +0800</pubDate>
      
      <guid>shanacean.github.io/notes/reader_dev/</guid>
      <description>Reader Dev ​	在之前学习flutter过程中，经常查阅Dart pub中的packages，便想到利用相同的形式做一个分享书籍的Web应用，无须注册，可以进行匿名的发布、修改润色他人分享的推书卡片，当然也可以进行删除。目前只开发了增删改查的工作，打星、评论的功能也会后续增加。
 一、开发过程 1.1 开发技术 使用了前后端分离技术，前端采用Vue3框架、后端采用SpringBoot2。
UI框架：TailwindCSS、ElementPlus
 ==TailwindCss==相比Boostrap更具自定义性，更能理解每一步做了什么，比纯css更方便。
 1.2	项目部署 利用腾讯云学生云服务器，学习了linux + docker的部署方式。
整个项目部署在三个docker容器中，分别对应着前端、后端和数据库。
1.3	在学习过程中使用的参考资料 Vue3中文文档
SpringBoot2教程
Tailwindcss
ElementPlus
docker部署vue项目
 二、项目过程中的问题解决 2.1	前端方面   vue 组件间相互通信问题
项目过程中的例子：
1、父组件调用子组件函数
在项目中存在父组件AddForm.vue 和 UploadImage.vue 两个组件。
//子组件UploadImage.vue中 &amp;lt;el-upload ref=&amp;#34;upload&amp;#34;&amp;gt;...&amp;lt;el-upload&amp;gt; //父组件AddForm.vue中 &amp;lt;upload-image @onLoadImage=&amp;#34;getImageUrl&amp;#34; ref=&amp;#34;upload&amp;#34;&amp;gt;&amp;lt;/upload-image&amp;gt; //表单提交后调用子组件中的clearImage()清除图片 this.$refs.upload.clearImage();  ref特性就是为元素或子组件赋予一个ID引用, 父组件中通过this.$refs.refName来访问元素或子组件的实例
 2、子组件向父组件传值
子组件通过 emit 传送
父组件使用 v-on 来绑定接收
//子组件中 handleSuccess(response) { this.url = response //传递上传后返回的图片的链接地址  this.$emit(&amp;#34;onLoadImage&amp;#34;, this.</description>
    </item>
    
  </channel>
</rss>
